#include "base/Graph.hpp" // Required to create the Graph object
#include "utils/logging.hpp"

#include <nexusflow/Pipeline.hpp>
#include <nexusflow/PipelineBuilder.hpp>

#include <memory>
#include <string>
#include <unordered_set>
#include <utility>
#include <vector>

namespace nexusflow {

// --- PipelineBuilder's Private Implementation (m_pImpl) ---
// This class is now extremely simple. It's just a data-holding struct
// to store the user's configuration before the Graph is built.
class PipelineBuilder::Impl {
public:
    std::vector<std::shared_ptr<Module>> modules;
    std::vector<std::pair<std::string, std::string>> connections;
};

// --- PipelineBuilder's Public Methods ---

PipelineBuilder::PipelineBuilder() : m_pImpl(std::make_unique<Impl>()) {}

PipelineBuilder::~PipelineBuilder() = default;

// --- Move Semantics ---
// The default move operations generated by the compiler are sufficient here.
PipelineBuilder::PipelineBuilder(PipelineBuilder&&) noexcept = default;
PipelineBuilder& PipelineBuilder::operator=(PipelineBuilder&&) noexcept = default;

PipelineBuilder& PipelineBuilder::AddModule(const std::shared_ptr<Module>& module) {
    if (m_pImpl && module) {
        m_pImpl->modules.push_back(std::move(module));
    }
    return *this;
}

PipelineBuilder& PipelineBuilder::Connect(const std::string& srcModuleName, const std::string& dstModuleName) {
    if (m_pImpl && !srcModuleName.empty() && !dstModuleName.empty()) {
        m_pImpl->connections.emplace_back(srcModuleName, dstModuleName);
    }
    return *this;
}

std::unique_ptr<Pipeline> PipelineBuilder::Build() {
    if (!m_pImpl) {
        return nullptr; // Builder has been consumed
    }

    // --- Step 1: Create a Graph object ---
    auto graph = std::make_unique<Graph>();
    graph->setName("Programmatically_Built_Pipeline"); // Or generate a unique name

    // --- Step 2: Create all Node objects and populate a lookup map ---
    // This map allows us to quickly find a Node shared_ptr by its name.
    std::unordered_map<std::string, std::shared_ptr<Node>> nodeLookupMap;

    for (const auto& module_ptr : m_pImpl->modules) {
        if (!module_ptr) continue;

        const std::string& moduleName = module_ptr->GetModuleName();
        auto node = std::make_shared<Node>(moduleName, "");
        node->modulePtr = module_ptr; // Assign the pre-created module instance

        nodeLookupMap[moduleName] = node;
    }

    // --- Step 3: Add edges to the graph based on connections ---
    if (m_pImpl->connections.empty() && m_pImpl->modules.size() > 1) {
        // Error: modules provided but no connections defined.
        return nullptr;
    }

    // Keep track of which nodes have incoming edges.
    std::unordered_set<std::string> nodesWithIncomingEdges;

    for (const auto& conn : m_pImpl->connections) {
        const std::string& fromName = conn.first;
        const std::string& toName = conn.second;

        auto fromIt = nodeLookupMap.find(fromName);
        auto toIt = nodeLookupMap.find(toName);

        if (fromIt == nodeLookupMap.end() || toIt == nodeLookupMap.end()) {
            // Error: Connection references a module that was not added.
            return nullptr;
        }

        graph->addEdge(fromIt->second, toIt->second);
        nodesWithIncomingEdges.insert(toName);
    }

    // --- Step 4: Heuristically determine the main input and output nodes ---
    // A simple heuristic:
    // - The main input node is one of the nodes that has no incoming edges.
    // - The main output node is one of the nodes that has no outgoing edges.
    // This logic might need to be more robust for complex graphs.

    std::shared_ptr<Node> sourceNode = nullptr;
    for (const auto& pair : nodeLookupMap) {
        if (nodesWithIncomingEdges.find(pair.first) == nodesWithIncomingEdges.end()) {
            // This node has no incoming edges, so it's a potential source.
            sourceNode = pair.second;
            break; // Pick the first one we find.
        }
    }

    // For simplicity, we'll assume the last node in the last connection is the sink.
    // A better way would be to check for nodes with an out-degree of 0.
    std::shared_ptr<Node> sinkNode = nullptr;
    if (!m_pImpl->connections.empty()) {
        sinkNode = nodeLookupMap.at(m_pImpl->connections.back().second);
    } else if (m_pImpl->modules.size() == 1) {
        // Handle single-node graph
        sourceNode = nodeLookupMap.at(m_pImpl->modules[0]->GetModuleName());
        sinkNode = sourceNode;
    }

    // --- Step 5: Check for cycles ---
    if (graph->hasCycle()) {
        // Error: The defined graph has a cycle.
        return nullptr;
    }

    // --- Step 6: Create the Pipeline from the fully constructed Graph ---
    auto pipeline = std::unique_ptr<Pipeline>(new Pipeline());
    pipeline->InitWithGraph(std::move(graph));

    m_pImpl.reset(); // Consume the builder

    return pipeline;
}

} // namespace nexusflow